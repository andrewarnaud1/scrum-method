<<<<<<< HEAD
from collections.abc import Sequence
from typing import TypeVar, Any, overload, Union, Literal
=======
from typing import List, TypeVar, Optional, Any, overload, Union, Tuple, Sequence, Literal
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58

from numpy import (
    ndarray,
    dtype,
    bool_,
<<<<<<< HEAD
    number,
    _OrderKACF,
)
from numpy._typing import (
=======
    unsignedinteger,
    signedinteger,
    floating,
    complexfloating,
    number,
    _OrderKACF,
)
from numpy.typing import (
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    _ArrayLikeBool_co,
    _ArrayLikeUInt_co,
    _ArrayLikeInt_co,
    _ArrayLikeFloat_co,
    _ArrayLikeComplex_co,
<<<<<<< HEAD
    _ArrayLikeObject_co,
=======
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    _DTypeLikeBool,
    _DTypeLikeUInt,
    _DTypeLikeInt,
    _DTypeLikeFloat,
    _DTypeLikeComplex,
    _DTypeLikeComplex_co,
<<<<<<< HEAD
    _DTypeLikeObject,
=======
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
)

_ArrayType = TypeVar(
    "_ArrayType",
    bound=ndarray[Any, dtype[Union[bool_, number[Any]]]],
)

<<<<<<< HEAD
_OptimizeKind = None | bool | Literal["greedy", "optimal"] | Sequence[Any]
_CastingSafe = Literal["no", "equiv", "safe", "same_kind"]
_CastingUnsafe = Literal["unsafe"]

__all__: list[str]
=======
_OptimizeKind = Union[
    None, bool, Literal["greedy", "optimal"], Sequence[Any]
]
_CastingSafe = Literal["no", "equiv", "safe", "same_kind"]
_CastingUnsafe = Literal["unsafe"]

__all__: List[str]
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58

# TODO: Properly handle the `casting`-based combinatorics
# TODO: We need to evaluate the content `__subscripts` in order
# to identify whether or an array or scalar is returned. At a cursory
# glance this seems like something that can quite easily be done with
# a mypy plugin.
# Something like `is_scalar = bool(__subscripts.partition("->")[-1])`
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeBool_co,
    out: None = ...,
    dtype: None | _DTypeLikeBool = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeBool_co,
    out: None = ...,
    dtype: Optional[_DTypeLikeBool] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeUInt_co,
    out: None = ...,
    dtype: None | _DTypeLikeUInt = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeUInt_co,
    out: None = ...,
    dtype: Optional[_DTypeLikeUInt] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeInt_co,
    out: None = ...,
    dtype: None | _DTypeLikeInt = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeInt_co,
    out: None = ...,
    dtype: Optional[_DTypeLikeInt] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeFloat_co,
    out: None = ...,
    dtype: None | _DTypeLikeFloat = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeFloat_co,
    out: None = ...,
    dtype: Optional[_DTypeLikeFloat] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeComplex_co,
    out: None = ...,
    dtype: None | _DTypeLikeComplex = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeComplex_co,
    out: None = ...,
    dtype: Optional[_DTypeLikeComplex] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: Any,
    casting: _CastingUnsafe,
    dtype: None | _DTypeLikeComplex_co = ...,
=======
    subscripts: str,
    /,
    *operands: Any,
    casting: _CastingUnsafe,
    dtype: Optional[_DTypeLikeComplex_co] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    out: None = ...,
    order: _OrderKACF = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeComplex_co,
    out: _ArrayType,
    dtype: None | _DTypeLikeComplex_co = ...,
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeComplex_co,
    out: _ArrayType,
    dtype: Optional[_DTypeLikeComplex_co] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> _ArrayType: ...
@overload
def einsum(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
=======
    subscripts: str,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    /,
    *operands: Any,
    out: _ArrayType,
    casting: _CastingUnsafe,
<<<<<<< HEAD
    dtype: None | _DTypeLikeComplex_co = ...,
    order: _OrderKACF = ...,
    optimize: _OptimizeKind = ...,
) -> _ArrayType: ...

@overload
def einsum(
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeObject_co,
    out: None = ...,
    dtype: None | _DTypeLikeObject = ...,
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: Any,
    casting: _CastingUnsafe,
    dtype: None | _DTypeLikeObject = ...,
    out: None = ...,
    order: _OrderKACF = ...,
    optimize: _OptimizeKind = ...,
) -> Any: ...
@overload
def einsum(
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeObject_co,
    out: _ArrayType,
    dtype: None | _DTypeLikeObject = ...,
    order: _OrderKACF = ...,
    casting: _CastingSafe = ...,
    optimize: _OptimizeKind = ...,
) -> _ArrayType: ...
@overload
def einsum(
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: Any,
    out: _ArrayType,
    casting: _CastingUnsafe,
    dtype: None | _DTypeLikeObject = ...,
=======
    dtype: Optional[_DTypeLikeComplex_co] = ...,
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
    order: _OrderKACF = ...,
    optimize: _OptimizeKind = ...,
) -> _ArrayType: ...

# NOTE: `einsum_call` is a hidden kwarg unavailable for public use.
# It is therefore excluded from the signatures below.
# NOTE: In practice the list consists of a `str` (first element)
# and a variable number of integer tuples.
def einsum_path(
<<<<<<< HEAD
    subscripts: str | _ArrayLikeInt_co,
    /,
    *operands: _ArrayLikeComplex_co | _DTypeLikeObject,
    optimize: _OptimizeKind = ...,
) -> tuple[list[Any], str]: ...
=======
    subscripts: str,
    /,
    *operands: _ArrayLikeComplex_co,
    optimize: _OptimizeKind = ...,
) -> Tuple[List[Any], str]: ...
>>>>>>> c03913b4420b10b4657dfb6a856eb245e1ebfb58
