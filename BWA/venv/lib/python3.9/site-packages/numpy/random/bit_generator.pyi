import abc
from threading import Lock
<<<<<<< HEAD
from collections.abc import Callable, Mapping, Sequence
from typing import (
    Any,
    NamedTuple,
=======
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Mapping,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Type,
>>>>>>> interface
    TypedDict,
    TypeVar,
    Union,
    overload,
    Literal,
)

from numpy import dtype, ndarray, uint32, uint64
<<<<<<< HEAD
from numpy._typing import _ArrayLikeInt_co, _ShapeLike, _SupportsDType, _UInt32Codes, _UInt64Codes
=======
from numpy.typing import _ArrayLikeInt_co, _ShapeLike, _SupportsDType, _UInt32Codes, _UInt64Codes
>>>>>>> interface

_T = TypeVar("_T")

_DTypeLikeUint32 = Union[
    dtype[uint32],
    _SupportsDType[dtype[uint32]],
<<<<<<< HEAD
    type[uint32],
=======
    Type[uint32],
>>>>>>> interface
    _UInt32Codes,
]
_DTypeLikeUint64 = Union[
    dtype[uint64],
    _SupportsDType[dtype[uint64]],
<<<<<<< HEAD
    type[uint64],
=======
    Type[uint64],
>>>>>>> interface
    _UInt64Codes,
]

class _SeedSeqState(TypedDict):
<<<<<<< HEAD
    entropy: None | int | Sequence[int]
    spawn_key: tuple[int, ...]
=======
    entropy: Union[None, int, Sequence[int]]
    spawn_key: Tuple[int, ...]
>>>>>>> interface
    pool_size: int
    n_children_spawned: int

class _Interface(NamedTuple):
    state_address: Any
    state: Any
    next_uint64: Any
    next_uint32: Any
    next_double: Any
    bit_generator: Any

class ISeedSequence(abc.ABC):
    @abc.abstractmethod
    def generate_state(
<<<<<<< HEAD
        self, n_words: int, dtype: _DTypeLikeUint32 | _DTypeLikeUint64 = ...
    ) -> ndarray[Any, dtype[uint32 | uint64]]: ...

class ISpawnableSeedSequence(ISeedSequence):
    @abc.abstractmethod
    def spawn(self: _T, n_children: int) -> list[_T]: ...

class SeedlessSeedSequence(ISpawnableSeedSequence):
    def generate_state(
        self, n_words: int, dtype: _DTypeLikeUint32 | _DTypeLikeUint64 = ...
    ) -> ndarray[Any, dtype[uint32 | uint64]]: ...
    def spawn(self: _T, n_children: int) -> list[_T]: ...

class SeedSequence(ISpawnableSeedSequence):
    entropy: None | int | Sequence[int]
    spawn_key: tuple[int, ...]
=======
        self, n_words: int, dtype: Union[_DTypeLikeUint32, _DTypeLikeUint64] = ...
    ) -> ndarray[Any, dtype[Union[uint32, uint64]]]: ...

class ISpawnableSeedSequence(ISeedSequence):
    @abc.abstractmethod
    def spawn(self: _T, n_children: int) -> List[_T]: ...

class SeedlessSeedSequence(ISpawnableSeedSequence):
    def generate_state(
        self, n_words: int, dtype: Union[_DTypeLikeUint32, _DTypeLikeUint64] = ...
    ) -> ndarray[Any, dtype[Union[uint32, uint64]]]: ...
    def spawn(self: _T, n_children: int) -> List[_T]: ...

class SeedSequence(ISpawnableSeedSequence):
    entropy: Union[None, int, Sequence[int]]
    spawn_key: Tuple[int, ...]
>>>>>>> interface
    pool_size: int
    n_children_spawned: int
    pool: ndarray[Any, dtype[uint32]]
    def __init__(
        self,
<<<<<<< HEAD
        entropy: None | int | Sequence[int] | _ArrayLikeInt_co = ...,
=======
        entropy: Union[None, int, Sequence[int], _ArrayLikeInt_co] = ...,
>>>>>>> interface
        *,
        spawn_key: Sequence[int] = ...,
        pool_size: int = ...,
        n_children_spawned: int = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def state(
        self,
    ) -> _SeedSeqState: ...
    def generate_state(
<<<<<<< HEAD
        self, n_words: int, dtype: _DTypeLikeUint32 | _DTypeLikeUint64 = ...
    ) -> ndarray[Any, dtype[uint32 | uint64]]: ...
    def spawn(self, n_children: int) -> list[SeedSequence]: ...

class BitGenerator(abc.ABC):
    lock: Lock
    def __init__(self, seed: None | _ArrayLikeInt_co | SeedSequence = ...) -> None: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]) -> None: ...
    def __reduce__(
        self,
    ) -> tuple[Callable[[str], BitGenerator], tuple[str], tuple[dict[str, Any]]]: ...
=======
        self, n_words: int, dtype: Union[_DTypeLikeUint32, _DTypeLikeUint64] = ...
    ) -> ndarray[Any, dtype[Union[uint32, uint64]]]: ...
    def spawn(self, n_children: int) -> List[SeedSequence]: ...

class BitGenerator(abc.ABC):
    lock: Lock
    def __init__(self, seed: Union[None, _ArrayLikeInt_co, SeedSequence] = ...) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: Dict[str, Any]) -> None: ...
    def __reduce__(
        self,
    ) -> Tuple[Callable[[str], BitGenerator], Tuple[str], Tuple[Dict[str, Any]]]: ...
>>>>>>> interface
    @abc.abstractmethod
    @property
    def state(self) -> Mapping[str, Any]: ...
    @state.setter
    def state(self, value: Mapping[str, Any]) -> None: ...
<<<<<<< HEAD
    @property
    def seed_seq(self) -> ISeedSequence: ...
    def spawn(self, n_children: int) -> list[BitGenerator]: ...
=======
>>>>>>> interface
    @overload
    def random_raw(self, size: None = ..., output: Literal[True] = ...) -> int: ...  # type: ignore[misc]
    @overload
    def random_raw(self, size: _ShapeLike = ..., output: Literal[True] = ...) -> ndarray[Any, dtype[uint64]]: ...  # type: ignore[misc]
    @overload
<<<<<<< HEAD
    def random_raw(self, size: None | _ShapeLike = ..., output: Literal[False] = ...) -> None: ...  # type: ignore[misc]
=======
    def random_raw(self, size: Optional[_ShapeLike] = ..., output: Literal[False] = ...) -> None: ...  # type: ignore[misc]
>>>>>>> interface
    def _benchmark(self, cnt: int, method: str = ...) -> None: ...
    @property
    def ctypes(self) -> _Interface: ...
    @property
    def cffi(self) -> _Interface: ...
